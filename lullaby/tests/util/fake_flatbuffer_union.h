/*
Copyright 2017-2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef LULLABY_TESTS_UTIL_FAKE_FLATBUFFER_UNION_H_
#define LULLABY_TESTS_UTIL_FAKE_FLATBUFFER_UNION_H_

#include <limits>
#include <unordered_map>
#include <vector>

#include "flatbuffers/flatbuffers.h"
#include "ion/base/logging.h"
#include "lullaby/util/typeid.h"

namespace lull {
namespace testing {

// This class allows a user to represent a union of flatbuffer / def types in
// code without specifying the types ahead of time in a .fbs file.
//
// Normally this is accomplished by code generated by flatc and the .fbs file
// is required to provide the schema (list of flatbuffer types).
//
// The FakeFlatbufferUnion maintains a global "active" union, which is used by
// clients to back their types.
//
// Usage:
// FakeFlatbuffersUnion* fb_union =
//      FakeFlatbufferUnion::Create<NameDefT, MyProjectSpecificDefT>();
// const char **comp_names = fb_union->GetTypeNames();
// CHECK(comp_names == {"NameDefT", "MyProjectSpecificDefT", nullptr});
// CHECK(FakeFlatbufferUnion::TypeToDefId<NameDefT>::value == 0);
//
// FakeFlatbufferUnion::SetActive(fb_union);
// CHECK(FakeFlatbufferUnion::TypeToDefId<NameDefT>::value == 1);
//
// FakeFlatbufferUnion::ClearActive();
// delete fb_union;
class FakeFlatbufferUnion {
 public:
  // Integer DefId which is used by the flatbuffers implementation.
  using DefId = uint8_t;

  // This helper template allows mapping directly from a def type to its
  // integral DefId when placed in the active union.  The value will be 0 for
  // any types that are not valid in the active union.
  template <typename T>
  struct TypeToDefId {
    static DefId value;
  };

  // Create a union with a specific set of types.
  // The union should be made active with SetActive() below in order to be fully
  // usable.
  template <typename... Types>
  static std::unique_ptr<FakeFlatbufferUnion> Create();

  // Mark the given union as the active one.
  //
  // Note: Generates a fatal error if another union is already active.
  static void SetActive(const FakeFlatbufferUnion* fake_union);

  // Clears the given active union and resets it to nullptr.
  static void ClearActive();

  // Gets the current active union.
  static const FakeFlatbufferUnion* GetActive() { return s_fake_union_; }

  // Gets a nullptr-terminated list of type names for the currently active
  // union.
  // If no union is currently active, a default list of typenames will be
  // returned, corresponding to an empty union.
  static const char** GetActiveTypeNames();

  // Gets a nullptr-terminated list of the names of all types that were
  // registered in this map.
  //
  // The first entry in the names list is always the string "NONE", representing
  // the lack of a type.
  // The names are unqualified.
  // The names are listed in the order that they were registered.
  //
  // The const_cast is necessary for conformance to the flatbuffers API.
  const char** GetTypeNames() const {
    return const_cast<const char**>(type_names_.data());
  }

  // Gets the number of registered type names, not including the terminating
  // nullptr.
  //
  // This will always be at least 1 due to the first list entry for "NONE".
  size_t GetTypeNamesCount() const { return type_names_.size() - 1; }

  // Gets the TypeId corresponding to the given integer DefId in this type map.
  // Returns 0 if the DefId is not valid in this type map.
  TypeId GetTypeId(DefId type) const;

  // Gets the integer DefId type corresponding to the given TypeId when it
  // is placed in this type map.  Returns 0 if the TypeID is not valid in this
  // type map.
  DefId GetDefId(TypeId type) const;

 private:
  using TypeNameList = std::vector<const char*>;
  using TypeIdList = std::vector<TypeId>;
  using TypeToDefMappingList = std::vector<DefId*>;
  using ReverseTypeMap = std::unordered_map<TypeId, DefId>;

  // Only Create<>() should be able to construct instances of this type.
  FakeFlatbufferUnion() {}

  template <typename... Types>
  void RegisterTypes();
  template <typename Type, typename... RemainingTypes>
  void RegisterTypeAndRecurse();
  void RegisterType(const char* fully_qualified_type_name, const TypeId type_id,
                    DefId* type_to_def_mapping = nullptr);
  void OnActivate() const;
  void OnDeactivate() const;

  static const FakeFlatbufferUnion* s_fake_union_;
  static const char* s_default_type_names_[2];

  TypeNameList type_names_;
  TypeIdList type_ids_;
  TypeToDefMappingList type_to_def_mappings_;
  ReverseTypeMap reverse_type_map_;
};

template <typename T>
FakeFlatbufferUnion::DefId FakeFlatbufferUnion::TypeToDefId<T>::value = 0;

template <typename... Types>
std::unique_ptr<FakeFlatbufferUnion> FakeFlatbufferUnion::Create() {
  FakeFlatbufferUnion* type_map = new FakeFlatbufferUnion();
  type_map->RegisterType("NONE", 0);  // Always include the "NONE" type.
  type_map->RegisterTypes<Types...>();

  return std::unique_ptr<FakeFlatbufferUnion>(type_map);
}

template <typename... Types>
void FakeFlatbufferUnion::RegisterTypes() {
  RegisterTypeAndRecurse<Types...>();
}

template <>
inline void FakeFlatbufferUnion::RegisterTypes() {
  // Finished recursively registering types, so add the required nullptr to the
  // names list now.
  type_names_.emplace_back(nullptr);
}

template <typename Type, typename... RemainingTypes>
void FakeFlatbufferUnion::RegisterTypeAndRecurse() {
  const char* type_name = Type::FlatBufferType::GetFullyQualifiedName();
  const TypeId type_id = lull::GetTypeId<Type>();
  DefId* type_to_def_mapping =
      &TypeToDefId<typename Type::FlatBufferType>::value;

  RegisterType(type_name, type_id, type_to_def_mapping);
  RegisterTypes<RemainingTypes...>();
}

}  // namespace testing
}  // namespace lull

#endif  // LULLABY_TESTS_UTIL_FAKE_FLATBUFFER_UNION_H_
