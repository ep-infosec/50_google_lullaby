/*
Copyright 2017-2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef LULLABY_MODULES_ECS_COMPONENT_HANDLERS_H_
#define LULLABY_MODULES_ECS_COMPONENT_HANDLERS_H_

#include <functional>
#include <unordered_map>

#include "flatbuffers/flatbuffers.h"
#include "lullaby/modules/ecs/blueprint_type.h"
#include "lullaby/util/flatbuffer_reader.h"
#include "lullaby/util/flatbuffer_writer.h"
#include "lullaby/util/inward_buffer.h"
#include "lullaby/util/span.h"
#include "lullaby/util/typeid.h"
#include "lullaby/util/variant.h"

namespace lull {

// Provides various handlers for ComponentDefT types, Lullaby's autogenerated
// wrappers of Flatbuffer types.
class ComponentHandlers {
 public:
  using DefType = BlueprintType::DefType;

  // Registers the ComponentDefT type and its handlers. It returns the hash
  // of the corresponding flatbuffer ComponentDef type name without namespaces,
  // e.g. Hash("TransformDef"), used as the argument for all subsequent API
  // calls.
  template <typename DefT>
  DefType RegisterComponentDefT();

  // Returns true if |def_type| has been registered.
  bool IsRegistered(DefType def_type) const;

  // Returns true if |def| could be Verified according to the schema for
  // |def_type|.
  bool Verify(DefType def_type, Span<uint8_t> def) const;

  // Using the schema registered for |def_type|, takes the ComponentDef table at
  // |def| and stores it as a ComponentDefT in |def_t_variant|.
  void ReadFromFlatbuffer(DefType def_type, Variant* def_t_variant,
                          const flatbuffers::Table* def) const;

  // Using the schema registered for |def_type|, takes the ComponentDefT in
  // |def_t_variant| and writes a finalized ComponentDef flatbuffer table into
  // |buffer|. Returns a pointer to the start of the data inside |buffer|.
  void* WriteToFlatbuffer(DefType def_type, Variant* def_t_variant,
                          InwardBuffer* buffer) const;

 private:
  // Functions that implement the API for a specifc type.
  using VerifyDefFn = std::function<bool(Span<uint8_t> def)>;
  using ReadDefFn = std::function<void(Variant* def_t_variant,
                                       const flatbuffers::Table* def)>;
  using WriteDefFn =
      std::function<void*(Variant* def_t_variant, InwardBuffer* buffer)>;

  // Contains the Handlers for each type of component.
  struct Handlers {
    VerifyDefFn verify;
    ReadDefFn read;
    WriteDefFn write;
  };

  // Returns the Handlers for the type, or null if not found.
  const Handlers* GetHandlers(DefType def_type) const;

  // List of Handlers for component types that have been registered.
  std::unordered_map<DefType, Handlers> handlers_;
};

template <typename DefT>
ComponentHandlers::DefType ComponentHandlers::RegisterComponentDefT() {
  Handlers handlers;
  handlers.verify = [](Span<uint8_t> def) {
    flatbuffers::Verifier verifier(def.data(), def.size());
    return verifier.VerifyBuffer<typename DefT::FlatBufferType>();
  };

  handlers.read = [](Variant* def_t_variant, const flatbuffers::Table* def) {
    *def_t_variant = DefT();
    ReadFlatbuffer(def_t_variant->Get<DefT>(), def);
  };

  handlers.write = [](Variant* def_t_variant, InwardBuffer* buffer) {
    if (def_t_variant->GetTypeId() != GetTypeId<DefT>()) {
      LOG(DFATAL) << "def_t_variant does not match type "
                  << GetTypeName<DefT>();
      return buffer->BackAt(buffer->BackSize());
    }
    return WriteFlatbuffer(def_t_variant->Get<DefT>(), buffer);
  };

  DefType name = BlueprintType::Create<DefT>().GetSchemaNameHash();
  handlers_.emplace(name, std::move(handlers));
  return name;
}

}  // namespace lull

#endif  // LULLABY_MODULES_ECS_COMPONENT_HANDLERS_H_
