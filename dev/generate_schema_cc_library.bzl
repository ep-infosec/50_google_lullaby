"""Generates a cc_library from flatbuffer schemas."""

load(
    ":utils_common.bzl",
    "FLATC_DEFAULT_INCLUDES",
    "FLATC_DEFAULT_INCLUDE_PATHS",
)

def generate_schema_cc_library(
        name,
        srcs,
        includes = [],
        include_paths = [],
        visibility = None,
        extra_hdrs = [],
        extra_deps = [],
        out_prefix = ""):
    """Generates a cc_library from flatbuffer schemas.

    This script is similar to the flat_cc_library except that it also generates
    code specifically to be used by Lullaby.  The resulting cc_library is a
    combination of the library generated by flat_cc_library and the code generated
    by lullaby/tools/flatc.  Lullaby clients are expected to use
    this rule for all System blueprint schemas.

    Args:
      name: Rule name.
      srcs: Source .fbs files. Sent in order to the compiler.
      includes: Optional, list of filegroups of schemas that the srcs depend on.
          ** SEE REMARKS BELOW **
      include_paths: Optional, list of paths the includes files can be found in.
      visibility: Visibility of the generated library.
      extra_hdrs: Extra .h files to be included in the cc_library.
      extra_deps: Extra dependencies to be included in the cc_library.
      out_prefix: Folder in which to place the generated files.

    Outs:
      cc_library(name): library with sources and flatbuffers deps.
      filegroup(name+"_includes"): schema files.  This is provided as a convenience
          since most of the time you often need the schemas as a filegroup when
          you are generating a cc_library for them.

    Remarks:
      ** Because the genrule used to call flatc does not have any trivial way of
        computing the output list of files transitively generated by includes and
        --gen-includes (the default) being defined for flatc, the --gen-includes
        flag will not work as expected. The way around this is to add a dependency
        to the flatbuffer_cc_library defined alongside the flatc included Fileset.
        For example you might define:

        flatbuffer_cc_library(
            name = "my_fbs",
            srcs = [ "schemas/foo.fbs" ],
            includes = [ "//third_party/bazz:bazz_fbs_includes" ],
        )

        In which foo.fbs includes a few files from the Fileset defined at
        //third_party/bazz:bazz_fbs_includes. When compiling the library that
        includes foo_generated.h, and therefore has my_fbs as a dependency, it
        will fail to find any of the bazz *_generated.h files unless you also
        add bazz's flatbuffer_cc_library to your own dependency list, e.g.:

        cc_library(
            name = "my_lib",
            deps = [
                ":my_fbs",
                "//third_party/bazz:bazz_fbs"
            ],
        )

        Happy dependent Flatbuffering!
    """
    full_includes = depset(FLATC_DEFAULT_INCLUDES + includes).to_list()
    full_include_paths = depset(FLATC_DEFAULT_INCLUDE_PATHS + include_paths).to_list()
    include_paths_cmd = ["-I %s" % (s) for s in full_include_paths]

    flatc_generator = "@flatbuffers//:flatc"
    flatc_args = include_paths_cmd[:]
    flatc_args.append("--no-union-value-namespacing")
    flatc_args.append("--gen-name-strings")
    flatc_args.append("--gen-mutable")
    flatc_args.append("-c")
    flatc_suffix = "_generated.h"
    flatc_out = out_prefix + "flatbuffers/"

    lull_generator = "//lullaby/tools/flatbuffer_code_generator"
    lull_args = include_paths_cmd[:]
    lull_args.append("-x")
    lull_args.append("--no-union-value-namespacing")
    lull_suffix = "_generated.h"
    lull_out = out_prefix

    cmds = [
        ["flatc", flatc_generator, flatc_args, flatc_out, flatc_suffix],
        ["lull", lull_generator, lull_args, lull_out, lull_suffix],
    ]

    generated_files = []
    for src in srcs:
        # Remove the path and get just the name of the file without the extension.
        basename = src.split("/")[-1].replace(".fbs", "")

        for label, generator, args, out_path, suffix in cmds:
            # Generate the full path for the generated code file.
            out = "%s%s%s" % (out_path, basename, suffix)
            generated_files.append(out)

            cmd = [
                "$(location %s)" % (generator),
                " ".join(args),
                "-o $(@D)",
                "$(location %s)" % (src),
            ]
            native.genrule(
                name = "generate_%s_code_%s" % (label, basename),
                srcs = [src] + full_includes,
                outs = [out],
                tools = [generator],
                cmd = " ".join(cmd),
                message = "Generating %s files for %s:" % (label, name),
            )

    # Generate the cc_libary from the generated code.
    native.cc_library(
        name = name,
        hdrs = extra_hdrs + generated_files,
        features = [
            "-parse_headers",
        ],
        deps = extra_deps + [
            "@flatbuffers//:flatbuffers",
            "@mathfu//:mathfu",
            "//lullaby/util:logging",
            "//lullaby/util:common_types",
            "//lullaby/util:optional",
        ],
        linkstatic = 1,
        visibility = visibility,
    )

    # A filegroup for all the schema files used to generate this library.
    native.filegroup(
        name = "%s_includes" % (name),
        srcs = srcs,
        visibility = visibility,
    )
