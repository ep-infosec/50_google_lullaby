"""Build Entity binary assets from Entity blueprint files."""

load(
    "//tools/build_defs/jsonnet:jsonnet.bzl",
    "jsonnet_library",
    "jsonnet_to_json",
)
load(
    ":utils_common.bzl",
    "FLATC_DEFAULT_ARGS",
    "FLATC_DEFAULT_INCLUDES",
    "FLATC_DEFAULT_INCLUDE_PATHS",
)

def build_entity_bin(
        name,
        srcs,
        schema,
        outdir = "",
        includes = [],
        include_paths = [],
        jsonnet_vars = {},
        jsonnet_deps = [],
        jsonnet_data = [],
        jsonnet_library_srcs = None,
        flatc_args = FLATC_DEFAULT_ARGS,
        visibility = ["//visibility:public"]):
    """Generates EntityDef binaries from Entity blueprint json (or jsonnet) files.

    If multiple json files with the same basename are used, they are merged into
    a single json file before being compiled into a binary.  See
    scripts/merge_blueprints.py for more details.

    Args:
      name: name for the filegroup contain the set of generated .bin files
      srcs: list of entity blueprint .json files
      schema: name for the entity fbs schema used to generate .bin files from
              entity blueprint .json files.
      outdir: optional, folder in which to generate output .bin files
      includes: Optional, list of filegroups of schemas that the srcs depend on.
      include_paths: Optional, list of paths the includes files can be found in.
      jsonnet_vars: Optional, dictionary of variable names and values passed to
                    the jsonnet_to_json generation.
      jsonnet_deps: Optional, list of jsonnet libraries that will be used as
                    dependencies during jsonnet to json conversion.
      jsonnet_data: Optional, list of files that may be used during jsonnet to
                    json conversion (typically via importstr).
      jsonnet_library_srcs: Optional, list of srcs to generate a jsonnet library
                            which will be used as a dependency for converting
                            jsonnet files to json files.
      flatc_args: List of additional arguments to pass to flatc.
      visibility: The visibility of the entity target. Defaults to public.

    Deprecated:
      Use build_blueprint.bzl instead.
    """
    merge_script = "//lullaby/tools:merge_blueprints"
    flatc_path = "@flatbuffers//:flatc"

    # TODO add schema+"_includes" to full includes when all apps are
    # using a schema generated by generate_entity_schema.
    full_includes = depset(FLATC_DEFAULT_INCLUDES + includes).to_list()
    full_include_paths = depset(FLATC_DEFAULT_INCLUDE_PATHS + include_paths).to_list()
    include_paths_cmd = ["-I %s" % (s) for s in full_include_paths]

    if outdir:
        outdir = "%s/" % outdir

    # Generate a jsonnet library if a set of library srcs is provided.
    jsonnet_all_deps = list(jsonnet_deps)
    if jsonnet_library_srcs:
        jsonnet_library_name = "jsonnet_library_%s" % name
        jsonnet_library(
            name = jsonnet_library_name,
            srcs = jsonnet_library_srcs,
        )
        jsonnet_all_deps.append(":%s" % jsonnet_library_name)

    # Generate list of .json files from the |srcs|.  If |srcs| contains
    # .jsonnet files, convert them to .json files first.
    json_srcs = []
    for src in srcs:
        if src.endswith(".json"):
            json_srcs.append(src)
        elif src.endswith(".jsonnet"):
            label_suffix = (outdir + src).replace("/", "_").replace(":", "_")

            # When a json src file is included from somewhere else in the //depot,
            # appending the outdir to the src file generates an unparseable out target
            # name, which needs to be cleaned here.
            # eg. outdir///third_party/... -> outdir/third_party/...
            # If outdir is empty, need to instead remove the "//" to put the generated
            # file in the current package.
            if outdir == "":
                out = (src.replace(":", "/")).replace("//", "").rsplit(".", 1)[0] + ".json"
            else:
                out = (outdir + src.replace(":", "/")).replace("///", "/").rsplit(".", 1)[0] + ".json"
            json_srcs.append(out)

            jsonnet_to_json(
                name = "jsonnet_to_json_%s" % label_suffix,
                src = src,
                outs = [out],
                deps = jsonnet_all_deps,
                data = jsonnet_data,
                ext_strs = jsonnet_vars,
            )

    # Iterate over json_srcs looking for duplicates to merge.
    merged_srcs = {}
    for src in json_srcs:
        # Extract the basename from the target path.
        basename = src[:-len(".json")]
        if ":" in basename:
            basename = basename.split(":")[-1]
        basename = basename.split("/")[-1]

        # Duplicate entry, use merge_blueprints to merge into a single json.
        if basename in merged_srcs:
            # iOS cannot run python scripts therefore, iOS cannot merge json files.
            if hasattr(native, "genmpm"):
                basefile = merged_srcs[basename]
                out = "generated/%s.json" % basename
                native.genrule(
                    name = "%s_merge_step" % (basename),
                    tools = [merge_script],
                    srcs = [basefile, src],
                    outs = [out],
                    cmd = " ".join([
                        "$(location %s)" % merge_script,
                        "-b $(location %s)" % basefile,
                        "-x $(location %s)" % src,
                        "-o $(location %s)" % out,
                    ]),
                )
                merged_srcs[basename] = out
            else:
                print("iOS cannot merge json files.")
                merged_srcs[basename] = src
        else:
            merged_srcs[basename] = src

    # Generate .bin files from .json files.
    outs = []
    for basename, src in merged_srcs.items():
        label_suffix = (outdir + basename).replace("/", "_")
        out = "%s%s.bin" % (outdir, basename)
        native.genrule(
            name = "generate_entity_%s" % (label_suffix),
            srcs = [src],
            outs = [out],
            tools = [flatc_path, schema] + full_includes,
            cmd = " ".join([
                "$(location %s)" % (flatc_path),
                " ".join(flatc_args),
                " ".join(include_paths_cmd),
                "-o $(@D)",
                "-b $(locations %s)" % (schema),
                "$(location %s)" % (src),
            ]),
            message = "Calling flatc for target %s" % (basename),
        )
        outs.append(out)

    # Create filegroup of generated .bin files.
    native.filegroup(
        name = name,
        srcs = outs,
        visibility = visibility,
    )

def _get_files_to_build(targets):
    """Returns all files built by targets in 'targets'."""
    result = depset()
    for dep in targets:
        result += dep.files
    return result

def _flatc(ctx):
    """Implementation for flatc_generate_binaries rule."""
    include_paths_cmd = []
    for s in ctx.attr.include_paths:
        include_paths_cmd += ["-I", s]
    common_srcs = _get_files_to_build(ctx.attr.includes)
    srcs = _get_files_to_build(ctx.attr.srcs)
    schemas = _get_files_to_build(ctx.attr.schema)
    schema_paths = [f.path for f in schemas]
    outs = depset()
    for src in srcs:
        bin_filename = src.short_path.rsplit(".", 1)[0] + ".bin"
        bin_file = ctx.new_file(ctx.genfiles_dir, bin_filename)
        out_dir = bin_file.path.rsplit("/", 1)[0]
        outs += [bin_file]
        ctx.actions.run(
            inputs = list(schemas + common_srcs + [src]),
            outputs = [bin_file],
            arguments = ctx.attr.flatc_args + include_paths_cmd +
                        ["-o", out_dir, "-b"] + schema_paths + [src.path],
            executable = ctx.executable._flatc_compiler,
        )
    return struct(files = outs, data_runfiles = ctx.runfiles(transitive_files = outs))

# Skylark rule to run flatc to compile json files to bin format.
flatc_generate_binaries = rule(
    implementation = _flatc,
    attrs = {
        # List of labels.
        # Defines the set of json sources to compile. For each json file,
        # a corresponding .bin file is compiled.
        "srcs": attr.label_list(
            allow_files = True,
            mandatory = True,
        ),
        # Schema include paths to search to handle includes from the fbs
        # schema.
        "include_paths": attr.string_list(),
        # Dependency labels for the included fbs schema files.
        "includes": attr.label_list(allow_files = True),
        # The flatbuffers schema for compiling the json files.
        "schema": attr.label_list(
            allow_files = True,
            mandatory = True,
        ),
        # Additional arguments to flatc
        "flatc_args": attr.string_list(),
        # The flatc compiler binary target.
        "_flatc_compiler": attr.label(
            executable = True,
            allow_files = True,
            cfg = "host",
            default = Label("@flatbuffers//:flatc"),
        ),
    },
)

def build_entities_filegroup(
        name,
        srcs,
        schema,
        includes = [],
        include_paths = [],
        flatc_args = FLATC_DEFAULT_ARGS):
    """Generates EntityDef binaries from Entity blueprint json files.

    This macro is similar to build_entity_bin but srcs can include a
    filegroup!

    Args:
      name: name for the filegroup contain the set of generated .bin files
      srcs: label list containing entity blueprint .json files
      schema: name for the entity fbs schema used to generate .bin files from
              entity blueprint .json files.
      includes: Optional, list of filegroups of schemas that the srcs depend on.
      include_paths: Optional, list of paths the includes files can be found in.
      flatc_args: List of additional arguments to pass to flatc.
    """
    full_includes = depset(FLATC_DEFAULT_INCLUDES + includes).to_list()
    full_include_paths = depset(FLATC_DEFAULT_INCLUDE_PATHS + include_paths).to_list()
    flatc_generate_binaries(
        name = name,
        srcs = srcs,
        include_paths = full_include_paths,
        includes = full_includes,
        schema = [schema],
        flatc_args = flatc_args,
    )
